--
-- Copyright (c) 2017-2024, Postgres Professional
--
-- Set of basic regression tests on scanning of a temporary table in parallel
--
-- Load the library. It should be load dynamically
LOAD 'tempscan';
-- Force usage of parallel workers
SET max_parallel_workers_per_gather = 3;
SET parallel_setup_cost = 0.0001;
SET parallel_tuple_cost = 0.0001;
-- Don't need big tables
SET min_parallel_table_scan_size = 0;
SET min_parallel_index_scan_size = 0;
CREATE TABLE parallel_test (x int);
INSERT INTO parallel_test (x) SELECT x FROM generate_series(1,100) AS x;
CREATE TEMP TABLE parallel_test_tmp AS (SELECT * FROM parallel_test);
VACUUM ANALYZE parallel_test, parallel_test_tmp;
SET tempscan.enable = 'on';
EXPLAIN (COSTS OFF)
SELECT count(*) FROM parallel_test;
                      QUERY PLAN                      
------------------------------------------------------
 Finalize Aggregate
   ->  Gather
         Workers Planned: 1
         ->  Partial Aggregate
               ->  Parallel Seq Scan on parallel_test
(5 rows)

-- Should also utilise parallel workers like scanning of a plain table
EXPLAIN (COSTS OFF)
SELECT count(*) FROM parallel_test_tmp;
                           QUERY PLAN                           
----------------------------------------------------------------
 Finalize Aggregate
   ->  Gather
         Workers Planned: 1
         ->  Partial Aggregate
               ->  Custom Scan (nodeCustomTempScan)
                     ->  Parallel Seq Scan on parallel_test_tmp
(6 rows)

-- Want to see here partial aggregate over parallel join
EXPLAIN (COSTS OFF)
SELECT count(*) FROM parallel_test t1 NATURAL JOIN parallel_test t2;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Finalize Aggregate
   ->  Gather
         Workers Planned: 1
         ->  Partial Aggregate
               ->  Parallel Hash Join
                     Hash Cond: (t1.x = t2.x)
                     ->  Parallel Seq Scan on parallel_test t1
                     ->  Parallel Hash
                           ->  Parallel Seq Scan on parallel_test t2
(9 rows)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM parallel_test_tmp t1 NATURAL JOIN parallel_test t2;
                               QUERY PLAN                                
-------------------------------------------------------------------------
 Finalize Aggregate
   ->  Gather
         Workers Planned: 1
         ->  Partial Aggregate
               ->  Parallel Hash Join
                     Hash Cond: (t1.x = t2.x)
                     ->  Custom Scan (nodeCustomTempScan)
                           ->  Parallel Seq Scan on parallel_test_tmp t1
                     ->  Parallel Hash
                           ->  Parallel Seq Scan on parallel_test t2
(10 rows)

-- Just see how merge join manages custom parallel scan path
SET enable_hashjoin = 'off';
EXPLAIN (COSTS OFF)
SELECT count(*) FROM parallel_test t1 NATURAL JOIN parallel_test t2;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Finalize Aggregate
   ->  Gather
         Workers Planned: 1
         ->  Partial Aggregate
               ->  Merge Join
                     Merge Cond: (t1.x = t2.x)
                     ->  Sort
                           Sort Key: t1.x
                           ->  Parallel Seq Scan on parallel_test t1
                     ->  Sort
                           Sort Key: t2.x
                           ->  Seq Scan on parallel_test t2
(12 rows)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM parallel_test_tmp t1 NATURAL JOIN parallel_test t2;
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Finalize Aggregate
   ->  Gather
         Workers Planned: 1
         ->  Partial Aggregate
               ->  Merge Join
                     Merge Cond: (t1.x = t2.x)
                     ->  Sort
                           Sort Key: t1.x
                           ->  Custom Scan (nodeCustomTempScan)
                                 ->  Parallel Seq Scan on parallel_test_tmp t1
                     ->  Sort
                           Sort Key: t2.x
                           ->  Seq Scan on parallel_test t2
(13 rows)

RESET enable_hashjoin;
RESET tempscan.enable;
DROP TABLE parallel_test, parallel_test_tmp;
