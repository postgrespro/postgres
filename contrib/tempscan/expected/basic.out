--
-- Copyright (c) 2017-2024, Postgres Professional
--
-- Set of basic regression tests on scanning of a temporary table in parallel
--
-- Load the library. It should be load dynamically
LOAD 'tempscan';
-- Force usage of parallel workers
SET max_parallel_workers_per_gather = 3;
SET parallel_setup_cost = 0.0001;
SET parallel_tuple_cost = 0.0001;
-- Don't need big tables
SET min_parallel_table_scan_size = 0;
SET min_parallel_index_scan_size = 0;
CREATE TABLE parallel_test (x int);
INSERT INTO parallel_test (x) SELECT x FROM generate_series(1,100) AS x;
CREATE TEMP TABLE parallel_test_tmp AS (SELECT * FROM parallel_test);
VACUUM ANALYZE parallel_test, parallel_test_tmp;
SET tempscan.enable = 'on';
SET tempscan.force = 'on';
EXPLAIN (COSTS OFF)
SELECT count(*) FROM parallel_test;
                      QUERY PLAN                      
------------------------------------------------------
 Finalize Aggregate
   ->  Gather
         Workers Planned: 1
         ->  Partial Aggregate
               ->  Parallel Seq Scan on parallel_test
(5 rows)

-- Do not use parallel scan of temporary table so far. As a result, shouldn't
-- find nodeCustomTempScan here
EXPLAIN (COSTS OFF)
SELECT count(*) FROM parallel_test_tmp;
             QUERY PLAN              
-------------------------------------
 Aggregate
   ->  Seq Scan on parallel_test_tmp
(2 rows)

-- Want to see here partial aggregate over parallel join
EXPLAIN (COSTS OFF)
SELECT count(*) FROM parallel_test t1 NATURAL JOIN parallel_test t2;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Finalize Aggregate
   ->  Gather
         Workers Planned: 1
         ->  Partial Aggregate
               ->  Parallel Hash Join
                     Hash Cond: (t1.x = t2.x)
                     ->  Parallel Seq Scan on parallel_test t1
                     ->  Parallel Hash
                           ->  Parallel Seq Scan on parallel_test t2
(9 rows)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM parallel_test_tmp t1 NATURAL JOIN parallel_test t2;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Finalize Aggregate
   ->  Gather
         Workers Planned: 1
         ->  Partial Aggregate
               ->  Hash Join
                     Hash Cond: (t2.x = t1.x)
                     ->  Parallel Seq Scan on parallel_test t2
                     ->  Hash
                           ->  Materialize
                                 ->  Custom Scan (nodeCustomTempScan)
                                       ->  Seq Scan on parallel_test_tmp t1
(11 rows)

-- Just see how merge join manages custom parallel scan path
SET enable_hashjoin = 'off';
EXPLAIN (COSTS OFF)
SELECT count(*) FROM parallel_test t1 NATURAL JOIN parallel_test t2;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Finalize Aggregate
   ->  Gather
         Workers Planned: 1
         ->  Partial Aggregate
               ->  Merge Join
                     Merge Cond: (t1.x = t2.x)
                     ->  Sort
                           Sort Key: t1.x
                           ->  Parallel Seq Scan on parallel_test t1
                     ->  Sort
                           Sort Key: t2.x
                           ->  Seq Scan on parallel_test t2
(12 rows)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM parallel_test_tmp t1 NATURAL JOIN parallel_test t2;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Finalize Aggregate
   ->  Gather
         Workers Planned: 1
         ->  Partial Aggregate
               ->  Merge Join
                     Merge Cond: (t2.x = t1.x)
                     ->  Sort
                           Sort Key: t2.x
                           ->  Parallel Seq Scan on parallel_test t2
                     ->  Sort
                           Sort Key: t1.x
                           ->  Materialize
                                 ->  Custom Scan (nodeCustomTempScan)
                                       ->  Seq Scan on parallel_test_tmp t1
(14 rows)

RESET enable_hashjoin;
-- Increase table size and see how indexes work
ALTER TABLE parallel_test ADD COLUMN y text DEFAULT 'none';
INSERT INTO parallel_test (x,y) SELECT x, 'data' || x AS y FROM generate_series(1,10000) AS x;
CREATE INDEX ON parallel_test_tmp (x);
VACUUM ANALYZE;
-- Use IndexScan on temporary table
EXPLAIN (COSTS OFF)
SELECT count(*) FROM parallel_test t1 NATURAL JOIN parallel_test_tmp t2
WHERE t1.x < 10;
                              QUERY PLAN                              
----------------------------------------------------------------------
 Aggregate
   ->  Gather
         Workers Planned: 3
         ->  Hash Join
               Hash Cond: (t1.x = t2.x)
               ->  Parallel Seq Scan on parallel_test t1
                     Filter: (x < 10)
               ->  Hash
                     ->  Materialize
                           ->  Custom Scan (nodeCustomTempScan)
                                 ->  Seq Scan on parallel_test_tmp t2
(11 rows)

CREATE TEMP TABLE parallel_test_tmp_2 AS (SELECT * FROM parallel_test);
CREATE INDEX ON parallel_test_tmp_2 (x);
VACUUM ANALYZE;
-- Can't use parallel workers here: for now temp tables can be used as parallel
-- safe source but not be read concurrently.
EXPLAIN (COSTS OFF)
SELECT count(*) FROM parallel_test_tmp t1 NATURAL JOIN parallel_test_tmp_2 t2
WHERE t2.x < 10;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Aggregate
   ->  Merge Join
         Merge Cond: (t1.x = t2.x)
         ->  Sort
               Sort Key: t1.x
               ->  Seq Scan on parallel_test_tmp t1
         ->  Index Only Scan using parallel_test_tmp_2_x_idx on parallel_test_tmp_2 t2
               Index Cond: (x < 10)
(8 rows)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM parallel_test_tmp_2 t1 NATURAL JOIN parallel_test_tmp_2 t2
WHERE t1.x < 10;
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 Aggregate
   ->  Nested Loop
         ->  Materialize
               ->  Custom Scan (nodeCustomTempScan)
                     ->  Index Scan using parallel_test_tmp_2_x_idx on parallel_test_tmp_2 t1
                           Index Cond: (x < 10)
         ->  Index Scan using parallel_test_tmp_2_x_idx on parallel_test_tmp_2 t2
               Index Cond: (x = t1.x)
               Filter: (y = t1.y)
(9 rows)

-- Employ parallel join using CustomScan as an inner
EXPLAIN (COSTS OFF)
SELECT count(*) FROM parallel_test t1 NATURAL JOIN parallel_test_tmp_2 t2
WHERE t1.x < 10 AND t2.x < 10;
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Gather
         Workers Planned: 3
         ->  Hash Join
               Hash Cond: ((t1.x = t2.x) AND (t1.y = t2.y))
               ->  Parallel Seq Scan on parallel_test t1
                     Filter: (x < 10)
               ->  Hash
                     ->  Materialize
                           ->  Custom Scan (nodeCustomTempScan)
                                 ->  Index Scan using parallel_test_tmp_2_x_idx on parallel_test_tmp_2 t2
                                       Index Cond: (x < 10)
(12 rows)

-- Parameterised NestLoop beats HashJoin. No ParallelTempScan possible
EXPLAIN (COSTS OFF)
SELECT count(*) FROM parallel_test t1 NATURAL JOIN parallel_test_tmp_2 t2
WHERE t1.x < 10;
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Aggregate
   ->  Nested Loop
         ->  Gather
               Workers Planned: 3
               ->  Parallel Seq Scan on parallel_test t1
                     Filter: (x < 10)
         ->  Index Scan using parallel_test_tmp_2_x_idx on parallel_test_tmp_2 t2
               Index Cond: (x = t1.x)
               Filter: (t1.y = y)
(9 rows)

-- Check real execution
EXPLAIN (VERBOSE, COSTS OFF)
SELECT count(*) FROM parallel_test t1 NATURAL JOIN parallel_test_tmp_2 t2;
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Aggregate
   Output: count(*)
   ->  Gather
         Workers Planned: 3
         ->  Hash Join
               Hash Cond: ((t1.x = t2.x) AND (t1.y = t2.y))
               ->  Parallel Seq Scan on public.parallel_test t1
                     Output: t1.x, t1.y
               ->  Hash
                     Output: t2.x, t2.y
                     ->  Materialize
                           Output: t2.x, t2.y
                           ->  Custom Scan (nodeCustomTempScan)
                                 Output: t2.x, t2.y
                                 ->  Seq Scan on pg_temp.parallel_test_tmp_2 t2
                                       Output: t2.x, t2.y
(16 rows)

SET max_parallel_workers_per_gather = 0;
SELECT count(*) FROM parallel_test t1 NATURAL JOIN parallel_test_tmp_2 t2;
 count 
-------
 10100
(1 row)

SET max_parallel_workers_per_gather = 3;
EXPLAIN (ANALYZE, COSTS OFF, TIMING OFF, SUMMARY OFF)
SELECT count(*) FROM parallel_test t1 NATURAL JOIN parallel_test_tmp_2 t2;
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Gather (actual rows=10100 loops=1)
         Workers Planned: 3
         Workers Launched: 3
         ->  Hash Join (actual rows=2525 loops=4)
               Hash Cond: ((t1.x = t2.x) AND (t1.y = t2.y))
               ->  Parallel Seq Scan on parallel_test t1 (actual rows=2525 loops=4)
               ->  Hash (actual rows=10100 loops=4)
                     Buckets: 16384 (originally 4096)  Batches: 1 (originally 1)  Memory Usage: 571kB
                     ->  Materialize (actual rows=10100 loops=4)
                           ->  Custom Scan (nodeCustomTempScan) (actual rows=10100 loops=4)
                                 ->  Seq Scan on parallel_test_tmp_2 t2 (actual rows=10100 loops=1)
(12 rows)

SELECT count(*) FROM parallel_test t1 NATURAL JOIN parallel_test_tmp_2 t2;
 count 
-------
 10100
(1 row)

RESET tempscan.force;
RESET tempscan.enable;
DROP TABLE parallel_test, parallel_test_tmp;
